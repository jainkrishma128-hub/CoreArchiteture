using CommonArchitecture.Web.Services;
using System.Net;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;

namespace CommonArchitecture.Web.Handlers
{
 public class RefreshTokenHandler : DelegatingHandler
 {
 private readonly ITokenService _tokenService;
 private readonly SemaphoreSlim _refreshLock = new SemaphoreSlim(1,1);

 public RefreshTokenHandler(ITokenService tokenService)
 {
 _tokenService = tokenService;
 }

 protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
 {
 // Attach access token if present
 var accessToken = await _tokenService.GetAccessTokenAsync();
 if (!string.IsNullOrEmpty(accessToken))
 {
 request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
 }

 var response = await base.SendAsync(request, cancellationToken);

 if (response.StatusCode != HttpStatusCode.Unauthorized)
 {
 return response;
 }

 //401 - try refresh once
 await _refreshLock.WaitAsync(cancellationToken);
 try
 {
 // Double-check if another refresh already updated the token
 var currentAccess = await _tokenService.GetAccessTokenAsync();
 if (!string.IsNullOrEmpty(currentAccess))
 {
 // retry original request with (possibly) updated token
 request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", currentAccess);
 var retryResponse = await base.SendAsync(CloneRequest(request), cancellationToken);
 if (retryResponse.StatusCode != HttpStatusCode.Unauthorized)
 {
 return retryResponse;
 }
 }

 var ok = await _tokenService.RefreshTokensAsync();
 if (!ok)
 {
 return response; // original401
 }

 // After refresh, retry original request with new token
 var newAccess = await _tokenService.GetAccessTokenAsync();
 if (!string.IsNullOrEmpty(newAccess))
 {
 var retry = CloneRequest(request);
 retry.Headers.Authorization = new AuthenticationHeaderValue("Bearer", newAccess);
 return await base.SendAsync(retry, cancellationToken);
 }

 return response;
 }
 finally
 {
 _refreshLock.Release();
 }
 }

 private static HttpRequestMessage CloneRequest(HttpRequestMessage request)
 {
 var clone = new HttpRequestMessage(request.Method, request.RequestUri);
 // copy request content
 if (request.Content != null)
 {
 var ms = new System.IO.MemoryStream();
 request.Content.CopyToAsync(ms).Wait();
 ms.Position =0;
 clone.Content = new StreamContent(ms);
 // copy headers
 foreach (var header in request.Content.Headers)
 clone.Content.Headers.TryAddWithoutValidation(header.Key, header.Value);
 }

 foreach (var header in request.Headers)
 clone.Headers.TryAddWithoutValidation(header.Key, header.Value);
 clone.Version = request.Version;
 return clone;
 }
 }
}
