# CommonArchitecture - Application Architecture

This document describes the application architecture for the solution located under `src/` and explains responsibilities, structure, and interactions for the six primary layers found in the workspace.

Projects map to layers
- `CommonArchitecture.Web` — Presentation (Razor Pages)
- `CommonArchitecture.API` — API Layer (REST)
- `CommonArchitecture.Application` — Application / Use Cases
- `CommonArchitecture.Core` — Domain / Core (entities, interfaces)
- `CommonArchitecture.Infrastructure` — Infrastructure (EF Core, external services)
- `src/tests` (`CommonArchitecture.UnitTests`, `CommonArchitecture.IntegrationTests`) — Test layer

Overview
This solution follows a clean / layered architecture with clear separation of concerns. The Application layer orchestrates use cases and depends on contracts defined in `Core`. `Infrastructure` implements those contracts (data access, external systems). `Web` and `API` are thin entry points that call `Application` services through dependency injection. Tests validate behavior across units and integration boundaries.

ASCII architecture diagram

 Client Browsers / Clients
 | +-----------------------+
 | | `CommonArchitecture.Web` |
 | | (Razor Pages UI) |
 | +-----------+-----------+
 | |
 | HTTP / AJAX | Calls Application services (via DI)
 v v
+-----------------+ +-----------------------+ +----------------------+
| Mobile/3rd party| <---> | `CommonArchitecture.API` | <---> | `CommonArchitecture.Application` |
| clients | REST | (REST endpoints) | CQRS | (Use cases / Handlers) |
+-----------------+ +-----------+-----------+ +-----------+----------+
 | |
 | uses interfaces | defines domain rules
 v v
 +-----------------------+ +----------------------+
 | `CommonArchitecture.Core` | | `CommonArchitecture.Infrastructure` |
 | (Domain: Entities, VOs) | | (EF Core, Repos, Clients) |
 +-----------------------+ +----------------------+


Data / Event flow example (simplified)
1. User submits form in `Web` or a client calls `API`.
2. Controller / PageModel maps request to a command / DTO and calls an `ICommandHandler` or `IApplicationService` in `Application`.
3. `Application` validates input, starts a transaction (if needed), calls repository interfaces from `Core` and publishes domain events.
4. `Infrastructure` provides `DbContext`, repository implementations, caches, and message bus publishers.
5. On success, `Application` returns DTOs; `Web` renders pages and `API` returns JSON responses.

Layer responsibilities and recommended structure

1) Presentation - `CommonArchitecture.Web` (Razor Pages)
- Responsibility: UI rendering, user input handling, authentication UI flows, client-side assets.
- Keep business logic out of PageModels; call into `Application` services.
- Typical folders: `Pages/`, `Pages/Shared/`, `wwwroot/`, `Models/ViewModels/`, `Services/` (UI helpers)
- Key files: `Program.cs` (wires DI), `_Layout.cshtml`, page models like `Pages/Orders/Create.cshtml.cs` that call `IOrderAppService`.

2) API - `CommonArchitecture.API`
- Responsibility: expose REST endpoints or gRPC, model mapping (DTOs), API versioning, authentication/authorization, rate limiting.
- Keep controllers thin: map requests to `Application` commands/queries.
- Typical folders: `Controllers/`, `DTOs/`, `Filters/`, `HealthChecks/`.
- Key aspects: use `ProblemDetails`, global exception handling middleware, API versioning, OpenAPI (Swagger).

3) Application - `CommonArchitecture.Application`
- Responsibility: orchestrate use cases, commands/queries, validation, transactions, mapping to domain models.
- Contains: `Commands/`, `Queries/`, `Handlers/` (e.g., MediatR handlers), `Services/`, `DTOs/`, `Mappers/`.
- Exposes interfaces or concrete `IOrderService`, `IUserService` used by controllers and PageModels.
- Should depend on abstractions in `Core` and not on `Infrastructure` implementations.

4) Core / Domain - `CommonArchitecture.Core`
- Responsibility: business model, entities, value objects, domain services, domain events, repository interfaces.
- Contains: `Entities/`, `ValueObjects/`, `Events/`, `Exceptions/`, `Interfaces/` (e.g., `IOrderRepository`).
- Keep domain logic here: invariants, validation rules, domain events.
- Example interface definition: `public interface IOrderRepository { Task<Order> GetByIdAsync(Guid id); Task SaveAsync(Order order); }

5) Infrastructure - `CommonArchitecture.Infrastructure`
- Responsibility: concrete implementations for persistence (EF Core `DbContext`), repository implementations, external integrations (HTTP clients), caching, message bus, file storage.
- Typical folders: `Persistence/`, `Repositories/`, `Data/` (migrations), `External/` (third-party clients), `Caching/`, `Messaging/`.
- Keep mapping between EF entities and domain entities here when using a persistence-ignorant domain model.
- Wire up `DbContext` and migrations; register implementations for `IOrderRepository` and other interfaces in `Program.cs` composition root.

6) Tests - `src/tests` (`CommonArchitecture.UnitTests`, `CommonArchitecture.IntegrationTests`)
- Responsibility: verify business rules, use cases, and integration with infrastructure.
- Unit tests target `Application` and `Core` pieces with mocked dependencies.
- Integration tests run against a test database / in-memory `DbContext` and real `Infrastructure` components when appropriate.
- Recommended structure: `UnitTests/Services/`, `IntegrationTests/Api/`, `Fixtures/` (shared setup), `TestHelpers/`.

Cross-cutting concerns and recommendations
- Dependency Injection: register services in `Program.cs` of `Web` and `API`. Keep composition root in these projects only.
- Logging/Monitoring: use `ILogger<T>`, structured logging, and forward logs to a provider (Seq, ELK, Application Insights).
- Configuration: use `IOptions<T>` and `appsettings.{Environment}.json`.
- Error handling: centralized exception middleware returning `ProblemDetails` and mapping known domain exceptions to appropriate HTTP statuses.
- Security: use ASP.NET Core Identity or JWT for API, apply authorization policies in `API` and `Web`.
- Transactions: keep transaction management in `Application` or `Infrastructure` with `UnitOfWork` patterns.
- Caching & Invalidation: use `IDistributedCache` (Redis) in `Infrastructure` and publish cache invalidation events; Application should evict or update cache on writes.
- Messaging / Events: use domain events to decouple side effects; publish integration events from `Infrastructure` message bus.

Example file/class mapping (suggested)
- `CommonArchitecture.Core/Entities/Order.cs` (domain entity)
- `CommonArchitecture.Core/Interfaces/IOrderRepository.cs` (contract)
- `CommonArchitecture.Application/Commands/CreateOrder/CreateOrderCommand.cs` and `CreateOrderHandler.cs`
- `CommonArchitecture.Infrastructure/Repositories/OrderRepository.cs` (EF Core implementation)
- `CommonArchitecture.API/Controllers/OrdersController.cs` (maps DTO -> command)
- `CommonArchitecture.Web/Pages/Orders/Create.cshtml.cs` (calls application service)

Sequence example for "Create Order"
- Client -> `OrdersController` (API) or `Pages/Orders/Create` (Web)
- Controller/PageModel -> create `CreateOrderCommand` -> send to handler in `Application` (MediatR)
- Handler -> validate -> `IOrderRepository.Add(order)` -> `DbContext.SaveChangesAsync()` (Infrastructure)
- Handler -> return `OrderDto` -> Controller returns201 Created
- Infrastructure publishes `OrderCreated` integration event if needed

Deployment and operational notes
- Containerize `API` and `Web` with a single `Dockerfile` per project or a multi-project build. Keep `Infrastructure` dependencies (e.g., database, Redis) as separate services.
- Use health checks (`Microsoft.Extensions.Diagnostics.HealthChecks`) exposed by `API` and `Web`.
- Manage secrets with your cloud provider (Key Vault, AWS Secrets Manager) or Kubernetes Secrets.

Checklist for maintaining the architecture
- Keep business rules in `Core` and `Application` only.
- No direct references from `Core` to `Infrastructure`.
- Register only interfaces in DI and implement them in `Infrastructure`.
- Write unit tests for `Application` handlers and domain logic; write integration tests for EF mappings and end-to-end flows.
- Document public APIs in Swagger for `API`.

Appendix: quick mapping to repo structure
```
/src
 /CommonArchitecture.Web
 Pages/
 Program.cs
 /CommonArchitecture.API
 Controllers/
 Program.cs
 /CommonArchitecture.Application
 Commands/
 Queries/
 Handlers/
 /CommonArchitecture.Core
 Entities/
 Interfaces/
 /CommonArchitecture.Infrastructure
 Persistence/
 Repositories/
 /tests
 CommonArchitecture.UnitTests
 CommonArchitecture.IntegrationTests
```

If you want, the next steps I can take:
- Generate a diagram image (SVG) and add it to `src/Documents/`.
- Create sample code snippets (interfaces and implementations) in each project to illustrate wiring.

