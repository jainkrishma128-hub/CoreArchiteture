# Adding a New Module - Step-by-Step Guide

This document provides a comprehensive, step-by-step guide for adding a new module to the CommonArchitecture solution. Follow this guide to understand the architecture flow and ensure consistency across the codebase.

**Example Module:** We'll use "Category" as an example throughout this guide.

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Step-by-Step File Creation](#step-by-step-file-creation)
3. [Complete Example: Category Module](#complete-example-category-module)
4. [Summary Checklist](#summary-checklist)
5. [Common Patterns & Best Practices](#common-patterns--best-practices)

---

## Architecture Overview

The solution follows a **Clean/Layered Architecture** with the following flow:

```
┌─────────────────────────────────────────────────────────────┐
│                    PRESENTATION LAYER                        │
│  ┌──────────────────┐              ┌──────────────────┐    │
│  │  Web (Razor)     │              │  API (REST)      │    │
│  │  - Controllers   │              │  - Controllers   │    │
│  │  - Views         │              │  - Endpoints     │    │
│  │  - Services      │              │                  │    │
│  └────────┬─────────┘              └────────┬─────────┘    │
└───────────┼──────────────────────────────────┼──────────────┘
            │                                  │
            │     ┌─────────────────────┐     │
            └────▶│  APPLICATION LAYER   │◀────┘
                  │  - Commands          │
                  │  - Queries           │
                  │  - DTOs              │
                  │  - Handlers          │
                  └──────────┬───────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  CORE LAYER   │   │INFRASTRUCTURE │   │  INFRASTRUCTURE│
│  - Entities   │   │    LAYER      │   │    LAYER      │
│  - Interfaces │   │  - Repositories│   │  - DbContext  │
│  (Contracts)  │   │  - Implementations│  - Migrations  │
└───────────────┘   └────────────────┘   └───────────────┘
```

**Data Flow:**
1. **User Request** → Web/API Controller
2. **Controller** → Application Command/Query (via MediatR)
3. **Handler** → Repository Interface (from Core)
4. **Repository Implementation** → Database (via DbContext)
5. **Response** → DTO → Controller → User

---

## Step-by-Step File Creation

Follow these steps **in order** to add a new module. Each step builds upon the previous one.

### **Step 1: Create Entity in Core Layer**

**Location:** `src/CommonArchitecture.Core/Entities/`

**File:** `Category.cs`

**Purpose:** Define the domain entity (database table representation)

**Example:**
```csharp
namespace CommonArchitecture.Core.Entities;

public class Category
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
}
```

**Why First?** This is the foundation - all other layers depend on the entity.

---

### **Step 2: Create Repository Interface in Core Layer**

**Location:** `src/CommonArchitecture.Core/Interfaces/`

**File:** `ICategoryRepository.cs`

**Purpose:** Define the contract for data access operations (Dependency Inversion Principle)

**Example:**
```csharp
using CommonArchitecture.Core.Entities;

namespace CommonArchitecture.Core.Interfaces;

public interface ICategoryRepository
{
    Task<IEnumerable<Category>> GetAllAsync();
    Task<Category?> GetByIdAsync(int id);
    Task<Category> AddAsync(Category category);
    Task UpdateAsync(Category category);
    Task DeleteAsync(int id);
}
```

**Why Second?** Application layer needs this interface to define operations.

---

### **Step 3: Add DbSet and Configuration in Infrastructure**

**Location:** `src/CommonArchitecture.Infrastructure/Persistence/ApplicationDbContext.cs`

**Changes Required:**

1. **Add DbSet property:**
```csharp
public DbSet<Category> Categories { get; set; }
```

2. **Add entity configuration in `OnModelCreating` method:**
```csharp
// Configure Category entity
modelBuilder.Entity<Category>(entity =>
{
    entity.HasKey(c => c.Id);
    entity.Property(c => c.Name).IsRequired().HasMaxLength(256);
    entity.Property(c => c.Description).HasMaxLength(1000);
    entity.Property(c => c.CreatedAt).HasDefaultValueSql("GETUTCDATE()");
    entity.HasIndex(c => c.Name).IsUnique(); // If name should be unique
});
```

**Why Third?** Database context needs to know about the entity before repositories can use it.

---

### **Step 4: Create Repository Implementation in Infrastructure**

**Location:** `src/CommonArchitecture.Infrastructure/Repositories/`

**File:** `CategoryRepository.cs`

**Purpose:** Implement the repository interface using Entity Framework Core

**Example:**
```csharp
using CommonArchitecture.Core.Entities;
using CommonArchitecture.Core.Interfaces;
using CommonArchitecture.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;

namespace CommonArchitecture.Infrastructure.Repositories;

public class CategoryRepository : ICategoryRepository
{
    private readonly ApplicationDbContext _context;

    public CategoryRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<Category>> GetAllAsync()
    {
        return await _context.Categories.ToListAsync();
    }

    public async Task<Category?> GetByIdAsync(int id)
    {
        return await _context.Categories.FindAsync(id);
    }

    public async Task<Category> AddAsync(Category category)
    {
        _context.Categories.Add(category);
        await _context.SaveChangesAsync();
        return category;
    }

    public async Task UpdateAsync(Category category)
    {
        _context.Categories.Update(category);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(int id)
    {
        var category = await _context.Categories.FindAsync(id);
        if (category != null)
        {
            _context.Categories.Remove(category);
            await _context.SaveChangesAsync();
        }
    }
}
```

**Why Fourth?** Infrastructure implements the contract defined in Core.

---

### **Step 5: Register Repository in Dependency Injection**

**Location:** `src/CommonArchitecture.API/Program.cs` AND `src/CommonArchitecture.Web/Program.cs`

**Add this line in the "Register repositories" section:**
```csharp
builder.Services.AddScoped<ICategoryRepository, CategoryRepository>();
```

**Why Fifth?** Services need to be registered before they can be injected.

---

### **Step 6: Create DTOs in Application Layer**

**Location:** `src/CommonArchitecture.Application/DTOs/`

**File:** `CategoryDto.cs`

**Purpose:** Data Transfer Objects for API/Web communication (separate from domain entities)

**Example:**
```csharp
namespace CommonArchitecture.Application.DTOs;

public class CategoryDto
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
}

public class CreateCategoryDto
{
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
}

public class UpdateCategoryDto
{
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
}
```

**Why Sixth?** DTOs are needed by Commands and Queries before they can be created.

---

### **Step 7: Create Commands (Create, Update, Delete)**

**Location:** `src/CommonArchitecture.Application/Commands/Categories/`

#### **7.1: Create Command**

**Files:**
- `CreateCategory/CreateCategoryCommand.cs`
- `CreateCategory/CreateCategoryCommandHandler.cs`

**CreateCategoryCommand.cs:**
```csharp
using CommonArchitecture.Application.Commands;
using CommonArchitecture.Application.DTOs;
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.CreateCategory;

public record CreateCategoryCommand(
    string Name,
    string Description
) : IRequest<CategoryDto>, ICacheInvalidator
{
    public string[] CacheKeys => new[] { "Categories_" };
}
```

**CreateCategoryCommandHandler.cs:**
```csharp
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Core.Entities;
using CommonArchitecture.Core.Interfaces;
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.CreateCategory;

public class CreateCategoryCommandHandler : IRequestHandler<CreateCategoryCommand, CategoryDto>
{
    private readonly ICategoryRepository _categoryRepository;

    public CreateCategoryCommandHandler(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    public async Task<CategoryDto> Handle(CreateCategoryCommand request, CancellationToken cancellationToken)
    {
        var category = new Category
        {
            Name = request.Name,
            Description = request.Description,
            CreatedAt = DateTime.UtcNow
        };

        var createdCategory = await _categoryRepository.AddAsync(category);

        return new CategoryDto
        {
            Id = createdCategory.Id,
            Name = createdCategory.Name,
            Description = createdCategory.Description
        };
    }
}
```

#### **7.2: Update Command**

**Files:**
- `UpdateCategory/UpdateCategoryCommand.cs`
- `UpdateCategory/UpdateCategoryCommandHandler.cs`

**UpdateCategoryCommand.cs:**
```csharp
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.UpdateCategory;

public record UpdateCategoryCommand(
    int Id,
    string Name,
    string Description
) : IRequest<bool>, ICacheInvalidator
{
    public string[] CacheKeys => new[] { "Categories_" };
}
```

**UpdateCategoryCommandHandler.cs:**
```csharp
using CommonArchitecture.Core.Interfaces;
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.UpdateCategory;

public class UpdateCategoryCommandHandler : IRequestHandler<UpdateCategoryCommand, bool>
{
    private readonly ICategoryRepository _categoryRepository;

    public UpdateCategoryCommandHandler(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    public async Task<bool> Handle(UpdateCategoryCommand request, CancellationToken cancellationToken)
    {
        var category = await _categoryRepository.GetByIdAsync(request.Id);
        if (category == null)
            return false;

        category.Name = request.Name;
        category.Description = request.Description;
        category.UpdatedAt = DateTime.UtcNow;

        await _categoryRepository.UpdateAsync(category);
        return true;
    }
}
```

#### **7.3: Delete Command**

**Files:**
- `DeleteCategory/DeleteCategoryCommand.cs`
- `DeleteCategory/DeleteCategoryCommandHandler.cs`

**DeleteCategoryCommand.cs:**
```csharp
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.DeleteCategory;

public record DeleteCategoryCommand(int Id) : IRequest<bool>, ICacheInvalidator
{
    public string[] CacheKeys => new[] { "Categories_" };
}
```

**DeleteCategoryCommandHandler.cs:**
```csharp
using CommonArchitecture.Core.Interfaces;
using MediatR;

namespace CommonArchitecture.Application.Commands.Categories.DeleteCategory;

public class DeleteCategoryCommandHandler : IRequestHandler<DeleteCategoryCommand, bool>
{
    private readonly ICategoryRepository _categoryRepository;

    public DeleteCategoryCommandHandler(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    public async Task<bool> Handle(DeleteCategoryCommand request, CancellationToken cancellationToken)
    {
        var category = await _categoryRepository.GetByIdAsync(request.Id);
        if (category == null)
            return false;

        await _categoryRepository.DeleteAsync(request.Id);
        return true;
    }
}
```

**Why Seventh?** Commands define write operations that the API will use.

---

### **Step 8: Create Queries (GetAll, GetById)**

**Location:** `src/CommonArchitecture.Application/Queries/Categories/`

#### **8.1: Get All Query**

**Files:**
- `GetAllCategories/GetAllCategoriesQuery.cs`
- `GetAllCategories/GetAllCategoriesQueryHandler.cs`

**GetAllCategoriesQuery.cs:**
```csharp
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Application.Queries;
using MediatR;

namespace CommonArchitecture.Application.Queries.Categories.GetAllCategories;

public record GetAllCategoriesQuery() : IRequest<IEnumerable<CategoryDto>>, ICacheableQuery
{
    public string CacheKey => "Categories_All";
    public TimeSpan? SlidingExpiration => TimeSpan.FromMinutes(10);
}
```

**GetAllCategoriesQueryHandler.cs:**
```csharp
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Core.Interfaces;
using MediatR;

namespace CommonArchitecture.Application.Queries.Categories.GetAllCategories;

public class GetAllCategoriesQueryHandler : IRequestHandler<GetAllCategoriesQuery, IEnumerable<CategoryDto>>
{
    private readonly ICategoryRepository _categoryRepository;

    public GetAllCategoriesQueryHandler(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    public async Task<IEnumerable<CategoryDto>> Handle(GetAllCategoriesQuery request, CancellationToken cancellationToken)
    {
        var categories = await _categoryRepository.GetAllAsync();
        return categories.Select(c => new CategoryDto
        {
            Id = c.Id,
            Name = c.Name,
            Description = c.Description
        });
    }
}
```

#### **8.2: Get By Id Query**

**Files:**
- `GetCategoryById/GetCategoryByIdQuery.cs`
- `GetCategoryById/GetCategoryByIdQueryHandler.cs`

**GetCategoryByIdQuery.cs:**
```csharp
using CommonArchitecture.Application.DTOs;
using MediatR;

namespace CommonArchitecture.Application.Queries.Categories.GetCategoryById;

public record GetCategoryByIdQuery(int Id) : IRequest<CategoryDto?>
{
}
```

**GetCategoryByIdQueryHandler.cs:**
```csharp
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Core.Interfaces;
using MediatR;

namespace CommonArchitecture.Application.Queries.Categories.GetCategoryById;

public class GetCategoryByIdQueryHandler : IRequestHandler<GetCategoryByIdQuery, CategoryDto?>
{
    private readonly ICategoryRepository _categoryRepository;

    public GetCategoryByIdQueryHandler(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    public async Task<CategoryDto?> Handle(GetCategoryByIdQuery request, CancellationToken cancellationToken)
    {
        var category = await _categoryRepository.GetByIdAsync(request.Id);
        if (category == null)
            return null;

        return new CategoryDto
        {
            Id = category.Id,
            Name = category.Name,
            Description = category.Description
        };
    }
}
```

**Why Eighth?** Queries define read operations that the API will use.

---

### **Step 9: Create API Controller**

**Location:** `src/CommonArchitecture.API/Controllers/`

**File:** `CategoriesController.cs`

**Purpose:** Expose REST endpoints for the Category module

**Example:**
```csharp
using CommonArchitecture.Application.Commands.Categories.CreateCategory;
using CommonArchitecture.Application.Commands.Categories.DeleteCategory;
using CommonArchitecture.Application.Commands.Categories.UpdateCategory;
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Application.Queries.Categories.GetAllCategories;
using CommonArchitecture.Application.Queries.Categories.GetCategoryById;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace CommonArchitecture.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class CategoriesController : ControllerBase
{
    private readonly IMediator _mediator;

    public CategoriesController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpGet]
    [AllowAnonymous]
    public async Task<ActionResult<IEnumerable<CategoryDto>>> GetAll()
    {
        var query = new GetAllCategoriesQuery();
        var result = await _mediator.Send(query);
        return Ok(result);
    }

    [HttpGet("{id}")]
    [AllowAnonymous]
    public async Task<ActionResult<CategoryDto>> GetById(int id)
    {
        var query = new GetCategoryByIdQuery(id);
        var category = await _mediator.Send(query);
        
        if (category == null)
            return NotFound();

        return Ok(category);
    }

    [HttpPost]
    [Authorize]
    public async Task<ActionResult<CategoryDto>> Create(CreateCategoryDto createDto)
    {
        var command = new CreateCategoryCommand(
            createDto.Name,
            createDto.Description
        );
        
        var category = await _mediator.Send(command);
        return CreatedAtAction(nameof(GetById), new { id = category.Id }, category);
    }

    [HttpPut("{id}")]
    [Authorize]
    public async Task<IActionResult> Update(int id, UpdateCategoryDto updateDto)
    {
        var command = new UpdateCategoryCommand(
            id,
            updateDto.Name,
            updateDto.Description
        );
        
        var result = await _mediator.Send(command);
        if (!result)
            return NotFound();

        return NoContent();
    }

    [HttpDelete("{id}")]
    [Authorize]
    public async Task<IActionResult> Delete(int id)
    {
        var command = new DeleteCategoryCommand(id);
        var result = await _mediator.Send(command);
        
        if (!result)
            return NotFound();

        return NoContent();
    }
}
```

**Why Ninth?** API controller exposes the application layer to external clients.

---

### **Step 10: Create Web API Service Interface**

**Location:** `src/CommonArchitecture.Web/Services/`

**File:** `ICategoryApiService.cs`

**Purpose:** Define the contract for Web to communicate with API

**Example:**
```csharp
using CommonArchitecture.Application.DTOs;

namespace CommonArchitecture.Web.Services;

public interface ICategoryApiService
{
    Task<IEnumerable<CategoryDto>> GetAllAsync();
    Task<CategoryDto?> GetByIdAsync(int id);
    Task<CategoryDto> CreateAsync(CreateCategoryDto createDto);
    Task<bool> UpdateAsync(int id, UpdateCategoryDto updateDto);
    Task<bool> DeleteAsync(int id);
}
```

**Why Tenth?** Interface defines the contract before implementation.

---

### **Step 11: Create Web API Service Implementation**

**Location:** `src/CommonArchitecture.Web/Services/`

**File:** `CategoryApiService.cs`

**Purpose:** HTTP client implementation to call API endpoints

**Example:**
```csharp
using CommonArchitecture.Application.DTOs;
using System.Net.Http.Json;

namespace CommonArchitecture.Web.Services;

public class CategoryApiService : ICategoryApiService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<CategoryApiService> _logger;

    public CategoryApiService(HttpClient httpClient, ILogger<CategoryApiService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<IEnumerable<CategoryDto>> GetAllAsync()
    {
        try
        {
            var result = await _httpClient.GetFromJsonAsync<IEnumerable<CategoryDto>>("api/categories");
            return result ?? Enumerable.Empty<CategoryDto>();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching categories from API");
            return Enumerable.Empty<CategoryDto>();
        }
    }

    public async Task<CategoryDto?> GetByIdAsync(int id)
    {
        try
        {
            return await _httpClient.GetFromJsonAsync<CategoryDto>($"api/categories/{id}");
        }
        catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching category {Id} from API", id);
            return null;
        }
    }

    public async Task<CategoryDto> CreateAsync(CreateCategoryDto createDto)
    {
        var response = await _httpClient.PostAsJsonAsync("api/categories", createDto);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<CategoryDto>() 
            ?? throw new Exception("Failed to deserialize response");
    }

    public async Task<bool> UpdateAsync(int id, UpdateCategoryDto updateDto)
    {
        try
        {
            var response = await _httpClient.PutAsJsonAsync($"api/categories/{id}", updateDto);
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating category {Id}", id);
            return false;
        }
    }

    public async Task<bool> DeleteAsync(int id)
    {
        try
        {
            var response = await _httpClient.DeleteAsync($"api/categories/{id}");
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting category {Id}", id);
            return false;
        }
    }
}
```

**Why Eleventh?** Service implementation provides HTTP communication to API.

---

### **Step 12: Register HTTP Client in Web Program.cs**

**Location:** `src/CommonArchitecture.Web/Program.cs`

**Add this in the HttpClient registration section:**
```csharp
builder.Services.AddHttpClient<ICategoryApiService, CategoryApiService>(client =>
{
    client.BaseAddress = new Uri(builder.Configuration["ApiSettings:BaseUrl"] ?? "http://localhost:5089");
    client.DefaultRequestHeaders.Add("Accept", "application/json");
})
.AddHttpMessageHandler<RefreshTokenHandler>();
```

**Why Twelfth?** HTTP client must be registered for dependency injection.

---

### **Step 13: Create Web Controller**

**Location:** `src/CommonArchitecture.Web/Areas/Admin/Controllers/`

**File:** `CategoriesController.cs`

**Purpose:** Handle HTTP requests from the web UI

**Example:**
```csharp
using CommonArchitecture.Application.DTOs;
using CommonArchitecture.Web.Filters;
using CommonArchitecture.Web.Services;
using FluentValidation;
using Microsoft.AspNetCore.Mvc;
using NToastNotify;

namespace CommonArchitecture.Web.Areas.Admin.Controllers;

[Area("Admin")]
[AuthorizeRole(1, 2)] // Admin and Product Manager roles
public class CategoriesController : Controller
{
    private readonly ICategoryApiService _categoryApiService;
    private readonly ILogger<CategoriesController> _logger;
    private readonly IValidator<CreateCategoryDto> _createValidator;
    private readonly IValidator<UpdateCategoryDto> _updateValidator;
    private readonly IToastNotification _toastNotification;

    public CategoriesController(
        ICategoryApiService categoryApiService,
        ILogger<CategoriesController> logger,
        IValidator<CreateCategoryDto> createValidator,
        IValidator<UpdateCategoryDto> updateValidator,
        IToastNotification toastNotification)
    {
        _categoryApiService = categoryApiService;
        _logger = logger;
        _createValidator = createValidator;
        _updateValidator = updateValidator;
        _toastNotification = toastNotification;
    }

    // GET: Admin/Categories
    public IActionResult Index()
    {
        return View();
    }

    // GET: Admin/Categories/GetAll - AJAX endpoint
    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        try
        {
            var categories = await _categoryApiService.GetAllAsync();
            return Json(new { success = true, data = categories });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error fetching categories");
            return Json(new { success = false, message = "Error loading categories" });
        }
    }

    // GET: Admin/Categories/Create
    public IActionResult Create()
    {
        return View(new CreateCategoryDto());
    }

    // POST: Admin/Categories/Create
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Create(CreateCategoryDto createDto)
    {
        var validationResult = await _createValidator.ValidateAsync(createDto);
        if (!validationResult.IsValid)
        {
            foreach (var error in validationResult.Errors)
            {
                ModelState.AddModelError(error.PropertyName, error.ErrorMessage);
            }
            return View(createDto);
        }

        try
        {
            await _categoryApiService.CreateAsync(createDto);
            _toastNotification.AddSuccessToastMessage("Category created successfully");
            return RedirectToAction(nameof(Index));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating category");
            _toastNotification.AddErrorToastMessage("Error creating category");
            return View(createDto);
        }
    }

    // GET: Admin/Categories/Edit/5
    public async Task<IActionResult> Edit(int id)
    {
        var category = await _categoryApiService.GetByIdAsync(id);
        if (category == null)
        {
            _toastNotification.AddErrorToastMessage("Category not found");
            return RedirectToAction(nameof(Index));
        }

        var updateDto = new UpdateCategoryDto
        {
            Name = category.Name,
            Description = category.Description
        };

        return View(updateDto);
    }

    // POST: Admin/Categories/Edit/5
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Edit(int id, UpdateCategoryDto updateDto)
    {
        var validationResult = await _updateValidator.ValidateAsync(updateDto);
        if (!validationResult.IsValid)
        {
            foreach (var error in validationResult.Errors)
            {
                ModelState.AddModelError(error.PropertyName, error.ErrorMessage);
            }
            return View(updateDto);
        }

        try
        {
            var result = await _categoryApiService.UpdateAsync(id, updateDto);
            if (result)
            {
                _toastNotification.AddSuccessToastMessage("Category updated successfully");
                return RedirectToAction(nameof(Index));
            }
            else
            {
                _toastNotification.AddErrorToastMessage("Category not found");
                return RedirectToAction(nameof(Index));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating category {Id}", id);
            _toastNotification.AddErrorToastMessage("Error updating category");
            return View(updateDto);
        }
    }

    // POST: Admin/Categories/Delete/5
    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Delete(int id)
    {
        try
        {
            var result = await _categoryApiService.DeleteAsync(id);
            if (result)
            {
                _toastNotification.AddSuccessToastMessage("Category deleted successfully");
            }
            else
            {
                _toastNotification.AddErrorToastMessage("Category not found");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting category {Id}", id);
            _toastNotification.AddErrorToastMessage("Error deleting category");
        }

        return RedirectToAction(nameof(Index));
    }
}
```

**Why Thirteenth?** Web controller handles UI requests and calls API service.

---

### **Step 14: Create Views**

**Location:** `src/CommonArchitecture.Web/Areas/Admin/Views/Categories/`

**Create the following view files:**

#### **14.1: Index.cshtml** (List view)

```html
@{
    ViewData["Title"] = "Categories";
    Layout = "~/Areas/Admin/Views/Shared/_AdminLayout.cshtml";
}

<div class="container-fluid">
    <div class="row mb-3">
        <div class="col-md-12">
            <h2>Categories</h2>
            <a asp-action="Create" class="btn btn-primary">Create New Category</a>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="card">
                <div class="card-body">
                    <table id="categoriesTable" class="table table-striped">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Name</th>
                                <th>Description</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be loaded via AJAX -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="~/js/admin-categories.js"></script>
}
```

#### **14.2: Create.cshtml**

```html
@model CommonArchitecture.Application.DTOs.CreateCategoryDto
@{
    ViewData["Title"] = "Create Category";
    Layout = "~/Areas/Admin/Views/Shared/_AdminLayout.cshtml";
}

<div class="container-fluid">
    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <h3>Create Category</h3>
                </div>
                <div class="card-body">
                    <form asp-action="Create" method="post">
                        <div asp-validation-summary="ModelOnly" class="text-danger"></div>
                        
                        <div class="form-group mb-3">
                            <label asp-for="Name" class="form-label"></label>
                            <input asp-for="Name" class="form-control" />
                            <span asp-validation-for="Name" class="text-danger"></span>
                        </div>

                        <div class="form-group mb-3">
                            <label asp-for="Description" class="form-label"></label>
                            <textarea asp-for="Description" class="form-control" rows="4"></textarea>
                            <span asp-validation-for="Description" class="text-danger"></span>
                        </div>

                        <div class="form-group">
                            <button type="submit" class="btn btn-primary">Create</button>
                            <a asp-action="Index" class="btn btn-secondary">Cancel</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
}
```

#### **14.3: Edit.cshtml**

```html
@model CommonArchitecture.Application.DTOs.UpdateCategoryDto
@{
    ViewData["Title"] = "Edit Category";
    Layout = "~/Areas/Admin/Views/Shared/_AdminLayout.cshtml";
}

<div class="container-fluid">
    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <h3>Edit Category</h3>
                </div>
                <div class="card-body">
                    <form asp-action="Edit" method="post">
                        <div asp-validation-summary="ModelOnly" class="text-danger"></div>
                        
                        <div class="form-group mb-3">
                            <label asp-for="Name" class="form-label"></label>
                            <input asp-for="Name" class="form-control" />
                            <span asp-validation-for="Name" class="text-danger"></span>
                        </div>

                        <div class="form-group mb-3">
                            <label asp-for="Description" class="form-label"></label>
                            <textarea asp-for="Description" class="form-control" rows="4"></textarea>
                            <span asp-validation-for="Description" class="text-danger"></span>
                        </div>

                        <div class="form-group">
                            <button type="submit" class="btn btn-primary">Update</button>
                            <a asp-action="Index" class="btn btn-secondary">Cancel</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
}
```

**Why Fourteenth?** Views provide the user interface for the module.

---

### **Step 15: Create JavaScript File (Optional but Recommended)**

**Location:** `src/CommonArchitecture.Web/wwwroot/js/`

**File:** `admin-categories.js`

**Purpose:** Handle AJAX calls for the index page data table

**Example:**
```javascript
$(document).ready(function() {
    loadCategories();

    function loadCategories() {
        $.ajax({
            url: '/Admin/Categories/GetAll',
            method: 'GET',
            success: function(response) {
                if (response.success) {
                    populateTable(response.data);
                }
            },
            error: function() {
                console.error('Error loading categories');
            }
        });
    }

    function populateTable(categories) {
        const tbody = $('#categoriesTable tbody');
        tbody.empty();

        categories.forEach(function(category) {
            const row = `
                <tr>
                    <td>${category.id}</td>
                    <td>${category.name}</td>
                    <td>${category.description}</td>
                    <td>
                        <a href="/Admin/Categories/Edit/${category.id}" class="btn btn-sm btn-primary">Edit</a>
                        <form asp-action="Delete" method="post" style="display:inline;">
                            <input type="hidden" name="id" value="${category.id}" />
                            <button type="submit" class="btn btn-sm btn-danger" onclick="return confirm('Are you sure?')">Delete</button>
                        </form>
                    </td>
                </tr>
            `;
            tbody.append(row);
        });
    }
});
```

**Why Fifteenth?** JavaScript enhances the user experience with dynamic content loading.

---

### **Step 16: Create Validators (Optional but Recommended)**

**Location:** `src/CommonArchitecture.Web/Validators/`

**File:** `CategoryValidators.cs`

**Purpose:** Server-side validation rules using FluentValidation

**Example:**
```csharp
using CommonArchitecture.Application.DTOs;
using FluentValidation;

namespace CommonArchitecture.Web.Validators;

public class CreateCategoryDtoValidator : AbstractValidator<CreateCategoryDto>
{
    public CreateCategoryDtoValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Name is required")
            .MaximumLength(256).WithMessage("Name must not exceed 256 characters");

        RuleFor(x => x.Description)
            .MaximumLength(1000).WithMessage("Description must not exceed 1000 characters");
    }
}

public class UpdateCategoryDtoValidator : AbstractValidator<UpdateCategoryDto>
{
    public UpdateCategoryDtoValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Name is required")
            .MaximumLength(256).WithMessage("Name must not exceed 256 characters");

        RuleFor(x => x.Description)
            .MaximumLength(1000).WithMessage("Description must not exceed 1000 characters");
    }
}
```

**Why Sixteenth?** Validators ensure data integrity and provide user-friendly error messages.

---

### **Step 17: Create Database Migration**

**Location:** Project root

**Command:**
```powershell
cd "D:\My Archi\Core"
dotnet ef migrations add AddCategoryTable -p src\CommonArchitecture.Infrastructure -s src\CommonArchitecture.Web
```

**Apply Migration:**
```powershell
dotnet ef database update -p src\CommonArchitecture.Infrastructure -s src\CommonArchitecture.Web
```

**Why Seventeenth?** Migration creates the database table for the new entity.

---

## Summary Checklist

Use this checklist to ensure you've completed all steps:

- [ ] **Step 1:** Created Entity in `Core/Entities/`
- [ ] **Step 2:** Created Repository Interface in `Core/Interfaces/`
- [ ] **Step 3:** Added DbSet and configuration in `ApplicationDbContext.cs`
- [ ] **Step 4:** Created Repository Implementation in `Infrastructure/Repositories/`
- [ ] **Step 5:** Registered Repository in `API/Program.cs` and `Web/Program.cs`
- [ ] **Step 6:** Created DTOs in `Application/DTOs/`
- [ ] **Step 7:** Created Commands (Create, Update, Delete) with Handlers
- [ ] **Step 8:** Created Queries (GetAll, GetById) with Handlers
- [ ] **Step 9:** Created API Controller in `API/Controllers/`
- [ ] **Step 10:** Created Web API Service Interface in `Web/Services/`
- [ ] **Step 11:** Created Web API Service Implementation in `Web/Services/`
- [ ] **Step 12:** Registered HTTP Client in `Web/Program.cs`
- [ ] **Step 13:** Created Web Controller in `Web/Areas/Admin/Controllers/`
- [ ] **Step 14:** Created Views (Index, Create, Edit) in `Web/Areas/Admin/Views/`
- [ ] **Step 15:** Created JavaScript file (optional)
- [ ] **Step 16:** Created Validators (optional)
- [ ] **Step 17:** Created and applied database migration

---

## Common Patterns & Best Practices

### **1. Naming Conventions**

- **Entities:** Singular noun (e.g., `Category`, `Product`)
- **Repositories:** Interface: `I{Entity}Repository`, Implementation: `{Entity}Repository`
- **DTOs:** `{Entity}Dto`, `Create{Entity}Dto`, `Update{Entity}Dto`
- **Commands:** `{Action}{Entity}Command` (e.g., `CreateCategoryCommand`)
- **Queries:** `{Action}{Entity}Query` (e.g., `GetAllCategoriesQuery`)
- **Controllers:** `{Entity}Controller` (plural)

### **2. Folder Structure**

```
Application/
  Commands/
    {Entity}/
      Create{Entity}/
        Create{Entity}Command.cs
        Create{Entity}CommandHandler.cs
      Update{Entity}/
      Delete{Entity}/
  Queries/
    {Entity}/
      GetAll{Entity}/
      Get{Entity}ById/
  DTOs/
    {Entity}Dto.cs
```

### **3. Dependency Flow**

```
Web/API Controller
  ↓ (uses)
Application Commands/Queries
  ↓ (uses)
Repository Interface (Core)
  ↓ (implemented by)
Repository Implementation (Infrastructure)
  ↓ (uses)
DbContext → Database
```

### **4. Key Principles**

- **Dependency Inversion:** Depend on abstractions (interfaces), not concretions
- **Single Responsibility:** Each class has one reason to change
- **Separation of Concerns:** Each layer has distinct responsibilities
- **DRY (Don't Repeat Yourself):** Reuse code through inheritance and composition

### **5. Error Handling**

- Use try-catch in API services and controllers
- Return appropriate HTTP status codes
- Log errors with `ILogger`
- Show user-friendly messages with toast notifications

### **6. Caching**

- Implement `ICacheableQuery` for read operations
- Implement `ICacheInvalidator` for write operations
- Use cache keys with entity prefixes (e.g., `Categories_`)

---

## Additional Resources

- **Architecture Overview:** See `01. Architecture.md`
- **Database Migrations:** See `02. Database Migration and Deployment Guide.md`
- **Existing Examples:** Study `Product`, `User`, or `Role` modules for reference

---

## Troubleshooting

### **Issue: Repository not found in DI**

**Solution:** Ensure you registered the repository in both `API/Program.cs` and `Web/Program.cs`

### **Issue: Handler not being called**

**Solution:** Ensure MediatR is registered in `Program.cs` (usually already configured)

### **Issue: Migration fails**

**Solution:** Review the entity configuration in `ApplicationDbContext.cs` and ensure all required properties are configured

### **Issue: API returns 404**

**Solution:** Check that the API controller route matches the service URL, and verify the API is running

---

This guide provides a complete roadmap for adding new modules to the architecture. Follow the steps in order, and refer to existing modules (Product, User, Role) for additional examples and patterns.

