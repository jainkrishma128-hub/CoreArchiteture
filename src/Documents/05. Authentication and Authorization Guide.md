# Authentication and Authorization - Complete Guide

This document provides a comprehensive explanation of how Authentication and Authorization work together in the CommonArchitecture solution, covering both the Web and API layers.

---

## Table of Contents

1. [Overview](#overview)
2. [Authentication vs Authorization](#authentication-vs-authorization)
3. [Authentication Flow](#authentication-flow)
4. [Authorization Mechanisms](#authorization-mechanisms)
5. [Web Layer Authorization](#web-layer-authorization)
6. [API Layer Authorization](#api-layer-authorization)
7. [Role-Based Access Control (RBAC)](#role-based-access-control-rbac)
8. [Permission-Based Access Control](#permission-based-access-control)
9. [Complete Request Flow](#complete-request-flow)
10. [Best Practices](#best-practices)

---

## Overview

The CommonArchitecture solution implements a **dual-layer authentication and authorization system**:

- **Web Layer**: Session-based authentication with custom authorization filters
- **API Layer**: JWT token-based authentication with ASP.NET Core authorization

Both layers work together to provide secure access control throughout the application.

---

## Authentication vs Authorization

### Authentication
**"Who are you?"**

Authentication verifies the identity of a user. It answers:
- Is the user who they claim to be?
- Has the user provided valid credentials?

**In This System:**
- User provides Mobile Number + OTP
- System validates credentials
- If valid, user is **authenticated** (logged in)

### Authorization
**"What can you do?"**

Authorization determines what an authenticated user is allowed to do. It answers:
- Does this user have permission to access this resource?
- What operations can this user perform?

**In This System:**
- Role-based authorization (Admin, Product Manager, etc.)
- Permission-based authorization (View, Create, Edit, Delete, Execute)
- Menu-based permissions (per feature/module)

---

## Authentication Flow

### Step-by-Step Authentication Process

```
┌──────────┐
│   User   │
└────┬─────┘
     │ 1. Enter Mobile Number
     ▼
┌──────────────────┐
│  Login Page      │
│  (Web UI)        │
└────┬─────────────┘
     │ 2. POST /api/auth/send-otp
     ▼
┌──────────────────┐
│  API Controller  │
│  (Auth)          │
└────┬─────────────┘
     │ 3. Generate OTP
     │    (Fixed: "1234" in dev)
     ▼
┌──────────────────┐
│  User Enters OTP │
└────┬─────────────┘
     │ 4. POST /api/auth/login
     │    { mobile, otp }
     ▼
┌──────────────────┐
│  API Controller  │
│  (Auth)          │
└────┬─────────────┘
     │ 5. Validate OTP
     │ 6. Get User from DB
     │ 7. Generate JWT Tokens
     │    - Access Token (15 min)
     │    - Refresh Token (7 days)
     ▼
┌──────────────────┐
│  JWT Service     │
│  Generate Tokens │
└────┬─────────────┘
     │ 8. Save Refresh Token to DB
     │ 9. Return Tokens + User Info
     ▼
┌──────────────────┐
│  Web Auth        │
│  Controller      │
└────┬─────────────┘
     │ 10. Save Tokens to Cookies
     │     (HTTP-Only, Secure)
     │ 11. Save User Info to Session
     │     (UserId, UserName, RoleId, etc.)
     ▼
┌──────────────────┐
│  User Authenticated │
│  ✓ Session Created │
│  ✓ Tokens Stored   │
└──────────────────┘
```

### Authentication Storage

**After successful login, the system stores:**

1. **JWT Tokens (HTTP-Only Cookies)**
   - `access_token`: JWT token for API authentication
   - `refresh_token`: Token for refreshing access token
   - `token_expires`: Expiration timestamp

2. **User Information (Session)**
   - `UserId`: User ID
   - `UserName`: User's full name
   - `UserEmail`: User's email
   - `UserMobile`: User's mobile number
   - `UserRoleId`: User's role ID (1 = Admin, 2 = Product Manager)
   - `UserRoleName`: User's role name

3. **Refresh Token (Database)**
   - Stored in `RefreshTokens` table
   - Used for token validation and refresh

---

## Authorization Mechanisms

The system uses multiple authorization mechanisms:

### 1. Session-Based Authorization (Web Layer)

**Purpose**: Check if user is logged in and has required role/permissions

**Storage**: Session data (stored server-side)

**Usage**: Web controllers, views, UI components

### 2. JWT Token-Based Authorization (API Layer)

**Purpose**: Validate JWT token and extract user claims

**Storage**: JWT token in HTTP header (Authorization: Bearer {token})

**Usage**: API endpoints, RESTful operations

### 3. Role-Based Authorization

**Purpose**: Restrict access based on user roles

**Roles**:
- **Admin (RoleId = 1)**: Full access to all features
- **Product Manager (RoleId = 2)**: Limited access (Products only)
- **User (RoleId = 3+)**: Custom roles with specific permissions

### 4. Permission-Based Authorization

**Purpose**: Granular control over specific operations

**Permissions**:
- `View`: Read/view data
- `Create`: Create new records
- `Edit`: Update existing records
- `Delete`: Delete records
- `Execute`: Execute special actions (export, import, etc.)

---

## Web Layer Authorization

### Authorization Attributes

The Web layer uses custom authorization attributes:

#### 1. `[AuthorizeUser]`

**Purpose**: Ensure user is authenticated (logged in)

**Location**: `src/CommonArchitecture.Web/Filters/AuthorizationFilters.cs`

**How it works:**
```csharp
public class AuthorizeUserAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        var userId = context.HttpContext.Session.GetString("UserId");
        
        if (string.IsNullOrEmpty(userId))
        {
            // User not authenticated - redirect to login
            context.Result = new RedirectToActionResult("Login", "Auth", new { area = "Admin" });
        }
        
        base.OnActionExecuting(context);
    }
}
```

**Usage:**
```csharp
[Area("Admin")]
[AuthorizeUser]  // Requires authentication
public class DashboardController : Controller
{
    // All actions require user to be logged in
}
```

**Flow:**
```
User Request → [AuthorizeUser] Filter
    ↓
Check Session for UserId
    ↓
If UserId exists → Allow request
If UserId missing → Redirect to Login
```

#### 2. `[AuthorizeRole(params int[] allowedRoles)]`

**Purpose**: Restrict access based on user roles

**Location**: `src/CommonArchitecture.Web/Filters/AuthorizationFilters.cs`

**How it works:**
```csharp
public class AuthorizeRoleAttribute : ActionFilterAttribute
{
    private readonly int[] _allowedRoles;

    public AuthorizeRoleAttribute(params int[] allowedRoles)
    {
        _allowedRoles = allowedRoles;
    }

    public override void OnActionExecuting(ActionExecutingContext context)
    {
        var userId = context.HttpContext.Session.GetString("UserId");
        var userRoleId = context.HttpContext.Session.GetString("UserRoleId");
        
        // Check if user is authenticated
        if (string.IsNullOrEmpty(userId))
        {
            context.Result = new RedirectToActionResult("Login", "Auth", new { area = "Admin" });
            return;
        }
        
        // Check if user has required role
        if (!string.IsNullOrEmpty(userRoleId) && int.TryParse(userRoleId, out int roleId))
        {
            if (!_allowedRoles.Contains(roleId))
            {
                // User doesn't have required role - redirect to access denied
                context.Result = new RedirectToActionResult("AccessDenied", "Error", new { area = "" });
                return;
            }
        }
        
        base.OnActionExecuting(context);
    }
}
```

**Usage Examples:**

```csharp
// Only Admin can access
[AuthorizeRole(1)]  // Admin only
public class UsersController : Controller
{
}

// Admin and Product Manager can access
[AuthorizeRole(1, 2)]  // Admin (1) and Product Manager (2)
public class ProductsController : Controller
{
}

// Multiple roles
[AuthorizeRole(1, 2, 3)]  // Admin, Product Manager, and Role 3
public class SomeController : Controller
{
}
```

**Flow:**
```
User Request → [AuthorizeRole] Filter
    ↓
Check Session for UserId
    ↓ (if authenticated)
Check Session for UserRoleId
    ↓
Compare UserRoleId with AllowedRoles
    ↓
If match → Allow request
If no match → Redirect to Access Denied
```

#### 3. `[HasPermission(string menuName, PermissionType permission)]`

**Purpose**: Granular permission-based access control

**Location**: `src/CommonArchitecture.Web/Filters/PermissionAuthorization.cs`

**How it works:**
```csharp
public class HasPermissionAttribute : TypeFilterAttribute
{
    public HasPermissionAttribute(string menuName, PermissionType permission) 
        : base(typeof(PermissionFilter))
    {
        Arguments = new object[] { menuName, permission };
    }
}

public class PermissionFilter : IAsyncAuthorizationFilter
{
    public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
    {
        // 1. Get User Role from Session
        var roleIdStr = context.HttpContext.Session.GetString("UserRoleId");
        if (string.IsNullOrEmpty(roleIdStr))
        {
            context.Result = new RedirectToActionResult("Login", "Auth", new { area = "Admin" });
            return;
        }
        
        // 2. Get Permissions for this Role from API
        var permissions = await _roleMenuService.GetRolePermissionsAsync(roleId);
        
        // 3. Check if user has required permission for this menu
        var menuPerm = permissions.MenuPermissions
            .FirstOrDefault(m => m.MenuName.Equals(menuName, StringComparison.OrdinalIgnoreCase));
        
        // 4. Validate specific permission
        bool isAuthorized = _permission switch
        {
            PermissionType.View => menuPerm.CanRead,
            PermissionType.Create => menuPerm.CanCreate,
            PermissionType.Edit => menuPerm.CanUpdate,
            PermissionType.Delete => menuPerm.CanDelete,
            PermissionType.Execute => menuPerm.CanExecute,
            _ => false
        };
        
        if (!isAuthorized)
        {
            context.Result = new RedirectToActionResult("AccessDenied", "Error", new { area = "" });
        }
    }
}
```

**Usage:**
```csharp
[Area("Admin")]
[AuthorizeUser]
[HasPermission("Dashboard", PermissionType.View)]  // Requires View permission for Dashboard
public class DashboardController : Controller
{
    [HasPermission("Dashboard", PermissionType.View)]
    public IActionResult Index()
    {
        return View();
    }
    
    [HasPermission("Products", PermissionType.Create)]
    public IActionResult Create()
    {
        // Only users with Create permission for Products can access
    }
}
```

**Permission Types:**
```csharp
public enum PermissionType
{
    View,      // Read/view data
    Create,    // Create new records
    Edit,      // Update existing records
    Delete,    // Delete records
    Execute    // Execute special actions (export, import, etc.)
}
```

**Flow:**
```
User Request → [HasPermission] Filter
    ↓
Get UserRoleId from Session
    ↓
Call API to get Role Permissions
    ↓
Find Menu Permission for specified menuName
    ↓
Check if required PermissionType is allowed
    ↓
If allowed → Allow request
If not allowed → Redirect to Access Denied
```

### Controller Authorization Examples

**Example 1: Dashboard (All authenticated users)**
```csharp
[Area("Admin")]
[AuthorizeUser]  // Any authenticated user
[HasPermission("Dashboard", PermissionType.View)]
public class DashboardController : Controller
{
}
```

**Example 2: Products (Admin and Product Manager)**
```csharp
[Area("Admin")]
[AuthorizeRole(1, 2)]  // Admin (1) and Product Manager (2)
public class ProductsController : Controller
{
}
```

**Example 3: Users (Admin only)**
```csharp
[Area("Admin")]
[AuthorizeRole(1)]  // Only Admin (1)
public class UsersController : Controller
{
}
```

**Example 4: Roles (Admin only)**
```csharp
[Area("Admin")]
[AuthorizeRole(1)]  // Only Admin (1)
public class RolesController : Controller
{
}
```

**Example 5: Logs (Admin only)**
```csharp
[Area("Admin")]
[AuthorizeRole(1)]  // Only Admin (1)
public class LogsController : Controller
{
}
```

---

## API Layer Authorization

### JWT Token Authentication

The API layer uses JWT Bearer token authentication.

**Configuration:**
```csharp
// src/CommonArchitecture.API/Program.cs

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,              // Verify issuer
        ValidateAudience = true,            // Verify audience
        ValidateLifetime = true,            // Check expiration
        ValidateIssuerSigningKey = true,    // Validate signature
        ValidIssuer = issuer,               // "CommonArchitecture.API"
        ValidAudience = audience,           // "CommonArchitecture.Web"
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),
        ClockSkew = TimeSpan.Zero          // No clock skew tolerance
    };
});
```

### Authorization Attributes (API)

#### 1. `[AllowAnonymous]`

**Purpose**: Allow unauthenticated access

**Usage:**
```csharp
[HttpGet]
[AllowAnonymous]  // No authentication required
public async Task<ActionResult<PaginatedResult<ProductDto>>> GetAll([FromQuery] ProductQueryParameters parameters)
{
    // Public endpoint - anyone can access
}
```

#### 2. `[Authorize]`

**Purpose**: Require valid JWT token (any authenticated user)

**Usage:**
```csharp
[HttpPost]
[Authorize]  // Requires valid JWT token
public async Task<ActionResult<ProductDto>> Create(CreateProductDto createDto)
{
    // Only authenticated users can access
    // Can access User.Claims for user information
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    var userRole = User.FindFirst(ClaimTypes.Role)?.Value;
}
```

#### 3. `[Authorize(Roles = "RoleName")]`

**Purpose**: Require specific role (from JWT token claims)

**Usage:**
```csharp
[HttpGet]
[Authorize(Roles = "Admin")]  // Only users with "Admin" role in JWT token
public async Task<ActionResult<IEnumerable<LogDto>>> GetAll([FromQuery] LogQueryParameters parameters)
{
    // Only Admin role can access
}
```

### JWT Token Claims

When a user logs in, the JWT token contains these claims:

```csharp
// Generated in JwtService.GenerateAccessToken()

var claims = new[]
{
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),           // User ID
    new Claim(ClaimTypes.Name, user.Name),                              // User Name
    new Claim(ClaimTypes.Email, user.Email),                            // User Email
    new Claim(ClaimTypes.MobilePhone, user.Mobile),                     // User Mobile
    new Claim(ClaimTypes.Role, user.Role?.RoleName ?? "User"),          // Role Name
    new Claim("RoleId", user.RoleId.ToString()),                        // Role ID
    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())   // Token ID
};
```

**Accessing Claims in API:**
```csharp
[HttpPost]
[Authorize]
public async Task<ActionResult> SomeAction()
{
    // Get user ID
    var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
    
    // Get user name
    var userName = User.FindFirst(ClaimTypes.Name)?.Value;
    
    // Get user role
    var userRole = User.FindFirst(ClaimTypes.Role)?.Value;
    
    // Get role ID
    var roleId = User.FindFirst("RoleId")?.Value;
    
    // Check if user has specific role
    var isAdmin = User.IsInRole("Admin");
    
    return Ok();
}
```

### API Controller Authorization Examples

**Example 1: Public Endpoint (No Authentication)**
```csharp
[HttpGet]
[AllowAnonymous]  // Public access
public async Task<ActionResult<PaginatedResult<ProductDto>>> GetAll([FromQuery] ProductQueryParameters parameters)
{
    // Anyone can access
}
```

**Example 2: Authenticated Endpoint**
```csharp
[HttpPost]
[Authorize]  // Any authenticated user
public async Task<ActionResult<ProductDto>> Create(CreateProductDto createDto)
{
    // Requires valid JWT token
}
```

**Example 3: Admin Only Endpoint**
```csharp
[HttpGet]
[Authorize(Roles = "Admin")]  // Only Admin role
public async Task<ActionResult<IEnumerable<LogDto>>> GetAll([FromQuery] LogQueryParameters parameters)
{
    // Only users with "Admin" role in JWT token
}
```

---

## Role-Based Access Control (RBAC)

### Role Definitions

**Role 1: Admin**
- Full access to all features
- Can manage users, roles, menus, permissions
- Can view system logs
- Can access Hangfire dashboard

**Role 2: Product Manager**
- Can manage products (CRUD operations)
- Can view dashboard
- Cannot access: Users, Roles, Menus, Logs

**Role 3+: Custom Roles**
- Defined by Admin
- Permissions assigned per menu
- Granular control via RoleMenu permissions

### Role-Based Authorization Matrix

| Controller/Feature | Admin (1) | Product Manager (2) | Custom Roles |
|-------------------|-----------|---------------------|--------------|
| Dashboard | ✅ | ✅ | Depends on permissions |
| Products | ✅ | ✅ | Depends on permissions |
| Users | ✅ | ❌ | Depends on permissions |
| Roles | ✅ | ❌ | Depends on permissions |
| Menus | ✅ | ❌ | Depends on permissions |
| Role Menus | ✅ | ❌ | Depends on permissions |
| Logs | ✅ | ❌ | Depends on permissions |
| Hangfire | ✅ | ❌ | Admin only |

---

## Permission-Based Access Control

### Permission System Architecture

```
┌──────────┐
│   Menu   │ (Feature/Module)
│          │ - Dashboard
│          │ - Products
│          │ - Users
│          │ - Roles
│          │ - etc.
└────┬─────┘
     │
     │ Has
     │
     ▼
┌──────────────┐
│  RoleMenu    │ (Permission Assignment)
│              │ - RoleId
│              │ - MenuId
│              │ - CanCreate
│              │ - CanRead
│              │ - CanUpdate
│              │ - CanDelete
│              │ - CanExecute
└────┬─────────┘
     │
     │ Assigned to
     │
     ▼
┌──────────┐
│   Role   │
│          │ - Admin
│          │ - Product Manager
│          │ - Custom Roles
└────┬─────┘
     │
     │ Assigned to
     │
     ▼
┌──────────┐
│   User   │
└──────────┘
```

### Permission Checking Flow

```
User Request → [HasPermission("MenuName", PermissionType)]
    ↓
Get UserRoleId from Session
    ↓
Call API: GetRolePermissionsAsync(roleId)
    ↓
API queries RoleMenu table for this Role
    ↓
Returns MenuPermissions DTO with permissions
    ↓
Filter checks specific menu permission
    ↓
Compare requested PermissionType with stored permission
    ↓
If allowed → Allow request
If not allowed → Redirect to Access Denied
```

### Permission Example

**Scenario**: User wants to create a product

1. User clicks "Create Product" button
2. Request goes to `ProductsController.Create()`
3. `[HasPermission("Products", PermissionType.Create)]` filter executes
4. Filter gets UserRoleId from Session (e.g., 2 = Product Manager)
5. Filter calls API to get permissions for RoleId 2
6. API returns: `{ MenuName: "Products", CanCreate: true, CanRead: true, ... }`
7. Filter checks `CanCreate` property
8. If `true` → Allow request
9. If `false` → Redirect to Access Denied

---

## Complete Request Flow

### Web Request Flow (Authenticated User)

```
┌──────────┐
│   User   │
│ Browser  │
└────┬─────┘
     │ 1. Request: GET /Admin/Products
     ▼
┌──────────────────┐
│  Web Controller  │
│  ProductsController│
└────┬─────────────┘
     │ 2. [AuthorizeRole(1, 2)] Filter
     │    - Check Session for UserId
     │    - Check Session for UserRoleId
     │    - Compare with allowed roles [1, 2]
     ▼
┌──────────────────┐
│  Authorization   │
│  Filter          │
└────┬─────────────┘
     │ 3. If authorized, continue
     │    If not authorized, redirect to Access Denied
     ▼
┌──────────────────┐
│  Controller      │
│  Action          │
│  Index()         │
└────┬─────────────┘
     │ 4. Calls API Service
     │    _productApiService.GetAllAsync()
     ▼
┌──────────────────┐
│  ProductApi      │
│  Service         │
└────┬─────────────┘
     │ 5. RefreshTokenHandler intercepts
     │    - Gets access_token from cookies
     │    - Adds Authorization header
     │    Authorization: Bearer {token}
     ▼
┌──────────────────┐
│  HTTP Request    │
│  GET /api/products│
│  + JWT Token     │
└────┬─────────────┘
     │ 6. API receives request
     ▼
┌──────────────────┐
│  API Controller  │
│  ProductsController│
└────┬─────────────┘
     │ 7. JWT Bearer Middleware
     │    - Validates token signature
     │    - Checks expiration
     │    - Verifies issuer/audience
     │    - Extracts claims
     │    - Sets User.Claims
     ▼
┌──────────────────┐
│  [AllowAnonymous]│
│  or [Authorize]  │
│  Check           │
└────┬─────────────┘
     │ 8. If authorized, execute action
     ▼
┌──────────────────┐
│  MediatR         │
│  Handler         │
│  GetAllProducts  │
└────┬─────────────┘
     │ 9. Query database
     ▼
┌──────────────────┐
│  Repository      │
│  ProductRepository│
└────┬─────────────┘
     │ 10. Return data
     ▼
┌──────────────────┐
│  Response        │
│  JSON Data       │
└──────────────────┘
```

### API Request Flow (Direct Client)

```
┌──────────┐
│  Client  │
│  (Mobile,│
│  Postman)│
└────┬─────┘
     │ 1. Request: POST /api/products
     │    Authorization: Bearer {jwt_token}
     ▼
┌──────────────────┐
│  API Controller  │
│  ProductsController│
└────┬─────────────┘
     │ 2. JWT Bearer Middleware
     │    - Validates token
     │    - Extracts claims
     │    - Sets User.Claims
     ▼
┌──────────────────┐
│  [Authorize]     │
│  Check           │
└────┬─────────────┘
     │ 3. Check if User is authenticated
     │    Check if User has required role (if specified)
     ▼
┌──────────────────┐
│  Controller      │
│  Action          │
│  Create()        │
└────┬─────────────┘
     │ 4. Execute action
     ▼
┌──────────────────┐
│  Response        │
└──────────────────┘
```

---

## Best Practices

### 1. Authentication Best Practices

✅ **Do:**
- Use HTTP-Only cookies for token storage (XSS protection)
- Use secure cookies in production (HTTPS only)
- Implement token expiration and refresh mechanism
- Validate tokens on every request
- Store refresh tokens securely in database
- Log authentication failures for security monitoring

❌ **Don't:**
- Store tokens in localStorage (vulnerable to XSS)
- Send sensitive data in URLs
- Use weak secret keys
- Allow unlimited login attempts (implement rate limiting)
- Store passwords in plain text

### 2. Authorization Best Practices

✅ **Do:**
- Use principle of least privilege (grant minimum required access)
- Implement role-based AND permission-based authorization
- Validate authorization on both client and server side
- Cache permissions to reduce database calls (when appropriate)
- Use consistent authorization patterns across the application
- Document role and permission requirements

❌ **Don't:**
- Rely only on client-side authorization (always validate on server)
- Hard-code role IDs in multiple places (use constants or enums)
- Grant unnecessary permissions
- Skip authorization checks "for convenience"
- Expose sensitive operations without proper authorization

### 3. Security Best Practices

✅ **Do:**
- Implement CSRF protection (SameSite cookies)
- Use HTTPS in production
- Implement rate limiting on authentication endpoints
- Monitor and log security events
- Regularly rotate JWT secret keys
- Implement token revocation mechanism

❌ **Don't:**
- Expose sensitive information in error messages
- Allow SQL injection (use parameterized queries)
- Trust client-side validation alone
- Store sensitive data in session unnecessarily
- Skip input validation

---

## Summary

The CommonArchitecture solution implements a **comprehensive authentication and authorization system**:

### Authentication
- ✅ Mobile Number + OTP authentication
- ✅ JWT token-based API authentication
- ✅ Session-based Web authentication
- ✅ Secure token storage (HTTP-Only cookies)
- ✅ Automatic token refresh

### Authorization
- ✅ Role-based access control (RBAC)
- ✅ Permission-based access control (PBAC)
- ✅ Menu-level permissions
- ✅ Custom authorization filters
- ✅ JWT token claims-based authorization

### Layers
- ✅ **Web Layer**: Session + Custom filters ([AuthorizeUser], [AuthorizeRole], [HasPermission])
- ✅ **API Layer**: JWT Bearer tokens ([Authorize], [AllowAnonymous], [Authorize(Roles = "...")])

This dual-layer approach provides **defense in depth** - security is enforced at multiple levels, ensuring that even if one layer is bypassed, the other layer provides protection.

